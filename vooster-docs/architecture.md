# 기술 요구사항 명세서 (TRD)

## 1. Executive Technical Summary
- **프로젝트 개요**: 본 프로젝트는 투자팀이 포트폴리오 기업(마인이스, 우나스텔라, 설로인)의 재무 정보를 신속하게 조회하고 분석할 수 있도록 지원하는 AI 기반 대화형 Q&A 챗봇을 구축하는 것을 목표로 합니다. 아키텍처는 React 프론트엔드와 FastAPI 백엔드를 중심으로 구성되며, PDF 문서를 Claude API에 직접 전송하는 심플한 방식으로 정확한 답변을 생성합니다.
- **핵심 기술 스택**: 프론트엔드는 React와 Tailwind CSS, 백엔드는 Python FastAPI를 사용합니다. 데이터 저장은 SQLite(메타데이터), Redis(캐시)를 활용하며, 핵심 AI 기능은 Anthropic의 Claude API를 통해 구현합니다.
- **주요 기술 목표**: 평균 응답 시간 3초 이내, 월 API 비용 10만원 미만, 시스템 가용성 99% 달성을 목표로 합니다. 초기에는 3개 기업의 재무제표를 대상으로 하며, 향후 필요시 확장 가능한 구조를 유지합니다.
- **핵심 기술 가정**: 사용자의 질의응답은 Claude API의 PDF 네이티브 지원 기능을 활용하여 처리되며, 전체 PDF를 직접 전송하는 방식으로 문맥 손실 없이 정확한 답변을 제공합니다. 초기 데이터(PDF)는 로컬 파일 시스템에 저장되고 메타데이터는 데이터베이스에서 관리됩니다.

## 2. 기술 스택

| 카테고리 | 기술 / 라이브러리 | 선정 사유 |
| --- | --- | --- |
| **프론트엔드** | React.js, Vite | 선언적 UI와 컴포넌트 기반 아키텍처로 복잡한 채팅 인터페이스를 효율적으로 구축할 수 있습니다. Vite는 빠른 개발 서버와 빌드 속도를 제공합니다. |
| **UI/스타일링** | Tailwind CSS | 유틸리티-우선 접근 방식으로 신속한 프로토타이핑과 일관된 디자인 시스템 적용이 용이합니다. |
| **백엔드 프레임워크** | FastAPI (Python) | 비동기 처리를 지원하여 I/O 바운드 작업(API 호출, DB 조회)이 많은 챗봇 특성에 적합하며, 자동 API 문서 생성으로 개발 생산성을 높입니다. |
| **데이터베이스 (메타데이터)** | PostgreSQL/SQLite | 문서 메타데이터를 관리하기 위한 관계형 데이터베이스입니다. 초기 개발은 SQLite로 시작하여 빠른 구축을, 프로덕션에서는 PostgreSQL로 전환하여 확장성을 확보합니다. |
| **캐시** | Redis | 인메모리 데이터 저장소로, 반복적인 API 응답과 검색 결과를 캐싱하여 시스템 응답 속도를 향상시키고 API 비용을 절감하는 데 필수적입니다. |
| **AI/LLM** | Claude 3 API | 한국어 처리 능력이 우수하고, 대용량 PDF 문서 분석에 강점을 보여 본 프로젝트의 핵심 요구사항인 문서 기반 질의응답에 가장 적합합니다. |
| **인프라/배포** | Docker, Nginx, Gunicorn | 컨테이너화를 통해 개발 및 배포 환경을 일치시키고, Nginx와 Gunicorn 조합은 안정적인 Python 웹 애플리케이션 서빙을 위한 표준 구성입니다. |

## 3. 시스템 아키텍처 설계

### 최상위 구성 요소
- **프론트엔드 (React Web UI)**: 사용자가 질문을 입력하고 답변을 확인하는 웹 기반 채팅 인터페이스입니다. API 서버와 통신하여 데이터를 주고받으며, 차트 시각화를 담당합니다.
- **웹 서버 (Nginx)**: 리버스 프록시 역할을 수행하며, 클라이언트의 요청을 백엔드 애플리케이션 서버로 전달합니다. 정적 파일 서빙 및 로드 밸런싱을 담당합니다.
- **백엔드 (FastAPI Server)**: 비즈니스 로직의 핵심으로, 사용자 요청 처리, 데이터베이스 및 외부 API 연동, PDF 직접 전송 파이프라인 실행 등 모든 서버 사이드 로직을 총괄합니다.
- **데이터 저장소**:
    - **PostgreSQL/SQLite**: 문서, 뉴스, 사용자 등의 메타데이터를 저장합니다. (초기에는 SQLite로 시작)
    - **Redis**: 자주 사용되는 데이터나 API 응답을 캐싱하여 성능을 향상시킵니다.
    - **File System**: 원본 PDF 문서 파일을 저장하고 관리합니다.
- **외부 서비스 (Claude API)**: 백엔드에서 전체 PDF와 사용자 질문을 직접 전달받아, 문서 내용을 분석하고 자연어 답변을 생성하는 핵심 LLM 서비스입니다.

### 최상위 컴포넌트 상호작용 다이어그램

```mermaid
graph TD
    subgraph 사용자 환경
        A[React 웹 UI]
    end

    subgraph 서버 인프라
        B[Nginx 리버스 프록시]
        C[FastAPI 백엔드 서버]
        D[SQLite/PostgreSQL<br/>(메타데이터)]
        E[Redis<br/>(캐시)]
        G[로컬 파일 시스템<br/>(PDF 원본)]
    end

    subgraph 외부 서비스
        H[Claude API]
    end

    A -- HTTPS --> B
    B -- HTTP --> C

    C -- PDF 직접 전송 --> H
    C -- CRUD --> D
    C -- 캐시 조회/저장 --> E
    C -- PDF 파일 읽기 --> G
```

- **사용자 요청 흐름**: 사용자는 React UI에서 질문을 입력하고, 이 요청은 Nginx를 통해 FastAPI 백엔드 서버로 전달됩니다.
- **백엔드 처리**: FastAPI 서버는 질문과 관련된 회사명을 파악하고, SQLite/PostgreSQL에서 해당 문서의 메타데이터를 조회하여 PDF 파일 경로를 확인합니다.
- **PDF 직접 전송 및 응답 생성**: 파일 시스템에서 PDF를 읽어 전체 내용을 사용자 질문과 함께 Claude API에 직접 전송합니다. Redis 캐시를 우선적으로 확인하여 동일한 질문에 대한 API 호출을 최소화합니다.
- **응답 반환**: Claude API로부터 받은 답변을 가공하여(텍스트, 출처 페이지 등) Nginx를 거쳐 React UI로 전송하여 사용자에게 표시합니다.

### 코드 구성 및 규칙
**도메인 주도 구성 전략**
- **도메인 분리**: 코드를 비즈니스 도메인(예: `chat`, `documents`, `users`, `auth`) 중심으로 구성하여 응집도를 높이고 결합도를 낮춥니다.
- **계층 기반 아키텍처**: 각 도메인 내부는 API(라우터), 서비스(비즈니스 로직), 리포지토리(데이터 접근) 계층으로 분리하여 관심사를 명확히 합니다.
- **공유 컴포넌트**: 여러 도메인에서 공통으로 사용되는 유틸리티, 설정, 기본 스키마 등은 `core` 또는 `shared` 모듈에 배치합니다.

**범용 파일 및 폴더 구조 (FastAPI 백엔드 기준)**
```
/
├── app/
│   ├── __init__.py
│   ├── main.py             # FastAPI 앱 초기화 및 미들웨어 설정
│   ├── api/                # API 엔드포인트 (라우터)
│   │   ├── __init__.py
│   │   ├── endpoints/
│   │   │   ├── chat.py
│   │   │   ├── documents.py
│   │   │   └── auth.py
│   │   └── deps.py         # 의존성 주입
│   ├── core/               # 핵심 로직 및 설정
│   │   ├── __init__.py
│   │   ├── config.py       # 환경 변수 및 설정
│   │   └── security.py     # 인증/보안 관련 유틸
│   ├── crud/               # 데이터베이스 CRUD 작업 (리포지토리)
│   │   ├── __init__.py
│   │   └── ...
│   ├── schemas/            # Pydantic 데이터 모델
│   │   ├── __init__.py
│   │   └── ...
│   ├── services/           # 비즈니스 로직
│   │   ├── __init__.py
│   │   ├── chat_service.py
│   │   └── rag_pipeline.py
│   └── db/                 # 데이터베이스 세션 및 초기화
│       ├── __init__.py
│       └── session.py
├── data/                   # 데이터 파일 (PRD 구조 참조)
│   └── ...
├── tests/                  # 테스트 코드
└── docker-compose.yml      # Docker 설정
```

### 데이터 흐름 및 통신 패턴
- **클라이언트-서버 통신**: 프론트엔드와 백엔드는 JSON 형식을 사용하는 RESTful API를 통해 통신합니다. 모든 통신은 HTTPS로 암호화됩니다.
- **데이터베이스 상호작용**: FastAPI는 SQLAlchemy ORM을 사용하여 PostgreSQL과 상호작용하며, 비동기 세션을 통해 효율적인 DB 접근을 관리합니다.
- **외부 서비스 통합**: 백엔드의 `rag_pipeline` 서비스가 Claude API와의 통신을 전담합니다. API 요청/응답 로직을 별도 모듈로 추상화하여 관리하고, 비용 및 사용량 모니터링 로직을 포함합니다.
- **실시간 통신**: 현재는 요청-응답 모델을 사용합니다. 향후 실시간 스트리밍 답변이 필요할 경우, WebSocket 또는 Server-Sent Events(SSE)를 도입하여 응답을 점진적으로 표시할 수 있습니다.
- **PDF 직접 전송 흐름**:
    1.  사용자 질문 수신
    2.  질문에서 회사명 추출 (예: "마인이스의 2024년 매출은?")
    3.  DB에서 해당 회사의 관련 문서 경로 조회
    4.  파일 시스템에서 PDF 파일 읽기
    5.  전체 PDF와 사용자 질문을 Claude API로 전송
    6.  LLM 답변 수신 후, 출처 정보와 함께 가공하여 사용자에게 반환

## 4. 성능 및 최적화 전략
- **응답 캐싱**: Redis를 활용하여 동일한 질문에 대한 LLM 응답과 자주 조회되는 문서 검색 결과를 캐싱합니다. 이를 통해 API 비용을 절감하고 평균 응답 시간을 3초 이내로 유지합니다.
- **LLM 라우팅 최적화**: 질문의 유형과 복잡도를 분석하여 Claude 3의 Opus, Sonnet, Haiku 모델을 동적으로 선택하는 라우팅 로직을 구현합니다. 단순 조회는 비용이 저렴한 Haiku를, 복잡한 분석은 Opus를 사용하여 비용 대비 성능을 최적화합니다.
- **비동기 처리 활용**: FastAPI의 비동기 기능을 최대한 활용하여 외부 API 호출, 데이터베이스 조회 등 I/O 바운드 작업을 병렬로 처리함으로써 전체 시스템의 처리량과 응답성을 높입니다.
- **데이터베이스 인덱싱**: PostgreSQL 테이블의 `company_name`, `published_date`, `year` 등 검색 조건으로 자주 사용되는 컬럼에 인덱스를 생성하여 쿼리 성능을 최적화합니다.

## 5. 구현 로드맵 및 마일스톤
### 1단계: 기반 구축 (MVP 구현, 2주)
- **핵심 인프라**: SQLite 기반 간단한 개발 환경, Redis 캐싱 설정을 완료합니다. (Docker는 선택사항)
- **필수 기능**: Claude API를 연동한 PDF 직접 전송 방식의 채팅 기능, 문서 메타데이터 관리, 기본 캐싱 기능을 구현합니다.
- **기본 보안**: API 통신을 위한 기본 설정만 적용합니다.
- **개발 환경**: FastAPI 프로젝트 구조 설정 및 Git 리포지토리 생성을 완료합니다.
- **예상 기간**: 1-2주

### 2단계: 기능 강화 (3-4주)
- **고급 기능**: 사용자 로그인 및 인증 시스템(JWT 기반), 재무 데이터 차트 시각화(Chart.js 연동), 검색 결과 캐싱 로직을 구현합니다.
- **성능 최적화**: 쿼리 최적화 및 응답 캐싱을 통해 시스템 성능을 개선합니다.
- **보안 강화**: HTTPS 적용 및 민감 정보 암호화 저장 방안을 마련합니다.
- **모니터링 구현**: 기본적인 API 요청/응답 로깅 시스템을 구축합니다.
- **예상 기간**: 2주

### 3단계: 확장 및 최적화 (2개월 후)
- **확장성 구현**: 두레이 메신저 연동을 위한 인터페이스 추상화 및 구현을 진행합니다.
- **고급 통합**: KIIPS ERP 연동을 위한 아키텍처를 설계하고 프로토타입을 개발합니다.
- **엔터프라이즈 기능**: 자동 리포트 생성, 다중 문서 비교 분석 등 고급 분석 기능을 추가합니다.
- **규정 준수 및 감사**: 내부 SSO 연동 및 접근 제어 정책을 강화합니다.
- **예상 기간**: 4주 이상

## 6. 리스크 평가 및 완화 전략
### 기술 리스크 분석
- **기술 리스크**: Claude API 장애 또는 성능 저하 발생 시, 시스템의 핵심 기능이 마비될 수 있습니다.
    - **완화 전략**: Gemini 등 대체 LLM으로 전환할 수 있는 폴백(Fallback) 로직을 구현하고, API 상태를 주기적으로 모니터링합니다.
- **성능 리스크**: 포트폴리오 기업 수가 증가하고 PDF 파일 크기가 커질수록 Claude API 응답 시간이 길어지고 비용이 증가할 수 있습니다.
    - **완화 전략**: Redis 캐싱을 적극 활용하여 동일한 질문에 대한 반복 호출을 방지합니다. PDF 크기가 너무 큰 경우(100MB 이상) 필요시 페이지 범위를 지정하여 전송하는 로직을 추가합니다. 향후 비용이 문제가 될 경우 벡터 인덱싱 방식으로 전환을 검토합니다.
- **보안 리스크**: 내부 재무 정보 등 민감 데이터를 다루므로, 비인가 접근 시 정보 유출의 위험이 있습니다.
    - **완화 전략**: 강력한 사용자 인증(향후 SSO 연동)을 적용하고, 데이터베이스 접근 제어 및 모든 통신 구간 암호화를 의무화합니다.
- **통합 리스크**: 향후 두레이, ERP 등 외부 시스템 연동 시 API 사양 변경이나 호환성 문제가 발생할 수 있습니다.
    - **완화 전략**: 외부 연동 모듈을 추상화된 인터페이스 기반으로 설계하여 특정 시스템에 대한 의존도를 낮추고, 변경에 유연하게 대응할 수 있도록 합니다.

### 프로젝트 납품 리스크
- **일정 리스크**: 1인 개발로 진행되므로, 예상치 못한 기술적 난관이나 요구사항 변경 시 일정 지연 가능성이 높습니다.
    - **대응 계획**: MVP 범위를 명확히 하고, 주간 단위로 진행 상황을 공유하며 위험 요소를 조기에 식별합니다. 일정 지연이 불가피할 경우, 우선순위가 낮은 기능(Could Have)부터 제외하는 방향으로 범위를 조정합니다.
- **자원 리스크**: 특정 기술(LLM, 벡터 DB)에 대한 전문성이 부족할 경우 개발 속도가 저하될 수 있습니다.
    - **대응 계획**: 커뮤니티와 공식 문서를 적극 활용하고, 복잡한 문제는 외부 전문가 자문을 구하는 방안을 고려합니다.
- **품질 리스크**: 빠른 개발 속도를 우선시하다 보면 테스트 커버리지가 부족해져 배포 후 버그가 발생할 수 있습니다.
    - **대응 계획**: 핵심 기능(RAG 파이프라인, 인증)에 대한 단위 테스트 및 통합 테스트 코드를 작성하여 코드 품질을 최소한으로 보장합니다.
- **배포 리스크**: 개발 환경과 운영 환경의 차이로 인해 배포 시 예상치 못한 문제가 발생할 수 있습니다.
    - **대응 계획**: Docker를 사용하여 환경을 일치시키고, 배포 전 스테이징 환경에서 충분한 테스트를 거칩니다. 배포 프로세스를 스크립트로 자동화하여 실수를 줄입니다.