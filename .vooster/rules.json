{
  "rules": [
    {
      "type": "prd",
      "content": "# 투자 포트폴리오 Q&A 챗봇 PRD v0.1\n\n**문서 버전**: 0.1  \n**작성일**: 2025-07-25  \n**작성자**: AI Assistant  \n**상태**: 초안\n\n---\n\n## 1. 제품 개요\n\n### 1.1 제품명\n투자 포트폴리오 Intelligence Assistant (가칭)\n\n### 1.2 비전\n투자팀이 120~250개 포트폴리오 기업의 뉴스와 재무 정보를 실시간으로 조회하고 인사이트를 얻을 수 있는 AI 기반 대화형 시스템\n\n### 1.3 핵심 가치\n- **즉시성**: 3초 내 필요한 정보 획득\n- **정확성**: 원본 문서 기반 팩트 체크\n- **효율성**: 수동 검색 시간 90% 감소\n\n### 1.4 성공 지표 (KPI)\n- 일일 활성 사용자(DAU): 3명 이상\n- 평균 응답 시간: 3초 이하\n- 월 API 비용: 10만원 이내\n- 시스템 가용성: 99%\n\n## 2. 사용자 요구사항\n\n### 2.1 타겟 사용자\n- **주 사용자**: 투자팀 전 직원 (약 10명)\n- **사용 환경**: 데스크톱 웹 브라우저\n- **기술 수준**: 일반 비즈니스 사용자\n\n### 2.2 핵심 사용 시나리오\n\n#### 시나리오 1: 재무 정보 조회\n```\n사용자: \"A기업 2024년 매출은?\"\n시스템: A기업의 2024년 재무제표를 찾아 분석\n응답: \"A기업의 2024년 매출은 1,234억원입니다. (2024년 사업보고서 p.23 기준)\"\n```\n\n#### 시나리오 2: 뉴스 검색\n```\n사용자: \"B기업 최근 인수합병 관련 뉴스 있어?\"\n시스템: 최근 3년 내 B기업 관련 뉴스에서 M&A 키워드 검색\n응답: \"B기업은 2024년 12월 C사를 500억원에 인수했습니다. 관련 뉴스 3건을 찾았습니다.\"\n```\n\n#### 시나리오 3: 문서 요약\n```\n사용자: \"D기업 작년 주주총회 내용 요약해줘\"\n시스템: 주주총회 관련 문서 검색 및 분석\n응답: \"2024년 3월 주주총회 주요 안건: 1) 배당금 주당 500원 승인 2) 신규 이사 선임...\"\n```\n\n### 2.3 기능 요구사항\n\n#### Must Have (Week 1-2)\n- [ ] FR-001: 웹 기반 채팅 인터페이스\n- [ ] FR-002: 기업명 기반 문서 검색\n- [ ] FR-003: Claude API를 통한 PDF 분석\n- [ ] FR-004: 뉴스 검색 및 표시\n- [ ] FR-005: 기본적인 질의응답 처리\n\n#### Should Have (Week 3)\n- [ ] FR-006: 사용자 로그인 시스템\n- [ ] FR-007: 검색 결과 캐싱\n- [ ] FR-008: 재무 데이터 차트 시각화\n- [ ] FR-009: 응답 출처 표시\n\n#### Could Have (Week 4)\n- [ ] FR-010: 두레이 연동 인터페이스\n- [ ] FR-011: 대화 히스토리 저장\n- [ ] FR-012: 고급 검색 필터\n- [ ] FR-013: 다중 문서 비교 분석\n\n### 2.4 비기능 요구사항\n\n#### 성능\n- NFR-001: 평균 응답 시간 3초 이내\n- NFR-002: 동시 사용자 5명 지원\n- NFR-003: 파일 크기 50MB까지 처리 가능\n\n#### 가용성\n- NFR-004: 99% 가용성 (계획된 유지보수 제외)\n- NFR-005: 24/7 서비스 제공\n\n#### 보안\n- NFR-006: 사용자 인증 필요\n- NFR-007: HTTPS 통신\n- NFR-008: 민감 정보 암호화 저장\n\n#### 확장성\n- NFR-009: 250개 기업까지 확장 가능\n- NFR-010: 두레이/ERP 연동 가능한 아키텍처\n\n## 3. 시스템 아키텍처\n\n### 3.1 기술 스택\n\n#### Frontend\n```yaml\nFramework: React.js 18\nStyling: Tailwind CSS 3.0\nCharts: Chart.js 4.0\nBuild Tool: Vite\nState Management: Context API\n```\n\n#### Backend\n```yaml\nFramework: FastAPI 0.110\nLanguage: Python 3.11\nDatabase: PostgreSQL 15\nCache: Redis 7\nVector DB: ChromaDB\nQueue: Celery (optional)\n```\n\n#### AI/ML\n```yaml\nPrimary LLM: Claude 3 Opus\nFallback LLM: Gemini Pro\nEmbeddings: sentence-transformers (jhgan/ko-sroberta-multitask)\n```\n\n#### Infrastructure\n```yaml\nContainer: Docker\nWeb Server: Nginx\nProcess Manager: Gunicorn\nMonitoring: Prometheus + Grafana (optional)\n```\n\n### 3.2 시스템 구성도\n\n```\n┌─────────────┐     ┌─────────────┐     ┌─────────────┐\n│   React     │────▶│   Nginx     │────▶│  FastAPI    │\n│   Web UI    │     │  (Reverse   │     │   Server    │\n└─────────────┘     │   Proxy)    │     └──────┬──────┘\n                    └─────────────┘              │\n                                                 │\n                    ┌─────────────────────────────┴─────────────────────────┐\n                    │                                                       │\n                    ▼                           ▼                           ▼\n            ┌─────────────┐             ┌─────────────┐            ┌─────────────┐\n            │ PostgreSQL  │             │    Redis    │            │  ChromaDB   │\n            │   (Meta)    │             │   (Cache)   │            │  (Vectors)  │\n            └─────────────┘             └─────────────┘            └─────────────┘\n                                                                            \n                    ┌─────────────┐             ┌─────────────┐\n                    │ File System │             │ Claude API  │\n                    │   (PDFs)    │             │   (LLM)     │\n                    └─────────────┘             └─────────────┘\n```\n\n### 3.3 데이터 모델\n\n#### 데이터베이스 스키마\n```sql\n-- 뉴스 메타데이터\nCREATE TABLE news (\n    id SERIAL PRIMARY KEY,\n    company_name VARCHAR(100) NOT NULL,\n    title TEXT NOT NULL,\n    content TEXT,\n    content_url TEXT,\n    source VARCHAR(100),\n    published_date TIMESTAMP,\n    created_at TIMESTAMP DEFAULT NOW(),\n    INDEX idx_company_date (company_name, published_date DESC)\n);\n\n-- 재무제표 인덱스\nCREATE TABLE financial_docs (\n    id SERIAL PRIMARY KEY,\n    company_name VARCHAR(100) NOT NULL,\n    doc_type VARCHAR(50), -- '사업보고서', '반기보고서', '분기보고서'\n    year INTEGER NOT NULL,\n    quarter INTEGER,\n    file_path TEXT NOT NULL,\n    file_size BIGINT,\n    created_at TIMESTAMP DEFAULT NOW(),\n    updated_at TIMESTAMP DEFAULT NOW(),\n    INDEX idx_company_year (company_name, year DESC)\n);\n\n-- 사용자 (확장성 고려)\nCREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    name VARCHAR(100),\n    password_hash TEXT,\n    is_active BOOLEAN DEFAULT true,\n    created_at TIMESTAMP DEFAULT NOW(),\n    last_login TIMESTAMP\n);\n\n-- 대화 히스토리 (선택적)\nCREATE TABLE chat_history (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER REFERENCES users(id),\n    question TEXT NOT NULL,\n    answer TEXT,\n    context JSONB, -- 검색된 문서 정보\n    created_at TIMESTAMP DEFAULT NOW()\n);\n```\n\n#### 파일 시스템 구조\n```\n/data/\n├── financial_docs/\n│   ├── {company_name}/\n│   │   ├── 2024/\n│   │   │   ├── annual_report_2024.pdf\n│   │   │   ├── Q1_report_2024.pdf\n│   │   │   └── ...\n│   │   └── ...\n│   └── ...\n└── cache/\n    └── embeddings/\n```\n\n### 3.4 API 설계\n\n#### 주요 엔드포인트\n```yaml\n# 채팅\nPOST /api/chat\nRequest: { \"question\": string, \"context\": object? }\nResponse: { \"answer\": string, \"sources\": array, \"charts\": array? }\n\n# 문서 검색\nGET /api/documents/search\nQuery: { \"company\": string, \"year\": number?, \"type\": string? }\nResponse: { \"documents\": array, \"total\": number }\n\n# 뉴스 검색\nGET /api/news/search\nQuery: { \"company\": string, \"keyword\": string?, \"from\": date?, \"to\": date? }\nResponse: { \"news\": array, \"total\": number }\n\n# 사용자 인증\nPOST /api/auth/login\nRequest: { \"email\": string, \"password\": string }\nResponse: { \"token\": string, \"user\": object }\n```\n\n## 4. 구현 계획\n\n### 4.1 개발 일정 (4주)\n\n#### Week 1: 기초 인프라 구축\n| 일차 | 작업 내용 | 산출물 |\n|------|-----------|---------|\n| Day 1-2 | 개발 환경 설정<br>- Docker 환경 구성<br>- PostgreSQL, Redis 설치<br>- FastAPI 프로젝트 생성 | Docker Compose 파일<br>기본 프로젝트 구조 |\n| Day 3-4 | 파일 시스템 구축<br>- 재무제표 폴더 구조화<br>- 파일 인덱싱 스크립트<br>- 메타데이터 DB 구축 | 파일 인덱서<br>DB 스키마 |\n| Day 5-7 | Claude API 연동<br>- PDF 처리 함수<br>- 프롬프트 템플릿<br>- 기본 채팅 API | Claude 연동 모듈<br>채팅 API v0.1 |\n\n#### Week 2: 검색 시스템 구현\n| 일차 | 작업 내용 | 산출물 |\n|------|-----------|---------|\n| Day 8-10 | 벡터 검색 구현<br>- ChromaDB 설정<br>- 뉴스 임베딩 파이프라인<br>- 검색 API 구현 | 벡터 검색 모듈<br>뉴스 검색 API |\n| Day 11-12 | 캐싱 시스템<br>- Redis 캐싱 로직<br>- 응답 시간 최적화 | 캐싱 레이어 |\n| Day 13-14 | 통합 테스트<br>- 전체 플로우 테스트<br>- 버그 수정 | 테스트 결과서 |\n\n#### Week 3: 프론트엔드 개발\n| 일차 | 작업 내용 | 산출물 |\n|------|-----------|---------|\n| Day 15-17 | 채팅 인터페이스<br>- React 채팅 컴포넌트<br>- 실시간 응답 표시<br>- 에러 처리 | 채팅 UI |\n| Day 18-19 | 데이터 시각화<br>- Chart.js 통합<br>- 재무 데이터 차트 | 차트 컴포넌트 |\n| Day 20-21 | 인증 시스템<br>- 로그인 페이지<br>- JWT 토큰 관리 | 인증 시스템 |\n\n#### Week 4: 최적화 및 배포\n| 일차 | 작업 내용 | 산출물 |\n|------|-----------|---------|\n| Day 22-23 | 성능 최적화<br>- 쿼리 최적화<br>- 동시성 처리 | 성능 개선 보고서 |\n| Day 24-25 | 배포 준비<br>- 프로덕션 설정<br>- 배포 스크립트 | 배포 가이드 |\n| Day 26-28 | 문서화<br>- 사용자 매뉴얼<br>- API 문서<br>- 운영 가이드 | 문서 세트 |\n\n### 4.2 MVP 범위 (2주차 완료 목표)\n\n#### 포함 기능\n- ✅ 기본 채팅 인터페이스 (터미널/간단한 웹)\n- ✅ 재무제표 PDF 검색 및 분석\n- ✅ 뉴스 메타데이터 검색\n- ✅ Claude API 연동\n- ✅ 기본 캐싱\n\n#### 제외 기능\n- ❌ 고급 UI/UX\n- ❌ 사용자 인증\n- ❌ 차트/시각화\n- ❌ 두레이 연동\n\n## 5. 비용 관리\n\n### 5.1 예상 사용량 계산\n```\n일일 예상 질문 수: 50개\n평균 토큰/질문:\n- 입력: 2,000 토큰 (컨텍스트 포함)\n- 출력: 500 토큰\n\n월간 토큰 사용량:\n50 질문/일 × 30일 × 2,500 토큰 = 3,750,000 토큰\n\n캐싱 적용 시 (50% 절감):\n실제 API 호출: 1,875,000 토큰\n```\n\n### 5.2 API 비용 최적화 전략\n\n#### 라우팅 로직\n```python\ndef select_llm_model(question_type, complexity):\n    if question_type == \"simple_lookup\":\n        return \"claude-3-haiku\"  # 저렴\n    elif complexity > 0.7:\n        return \"claude-3-opus\"   # 고급 분석\n    else:\n        return \"claude-3-sonnet\" # 중간\n```\n\n#### 예상 월 비용 분배\n- Claude Opus (30%): 6만원\n- Claude Sonnet (50%): 3만원  \n- Claude Haiku (20%): 1만원\n- **총 예상: 10만원/월**\n\n### 5.3 비용 모니터링\n```python\n# 일일 비용 한도 설정\nDAILY_COST_LIMIT = 3500  # 원\ncurrent_cost = await redis.get(\"daily_api_cost\")\nif current_cost > DAILY_COST_LIMIT:\n    return \"일일 API 한도 초과. 내일 다시 시도해주세요.\"\n```\n\n## 6. 리스크 관리\n\n### 6.1 기술적 리스크\n\n| 리스크 | 영향도 | 발생확률 | 대응 방안 |\n|--------|--------|----------|-----------|\n| Claude API 장애 | 높음 | 낮음 | Gemini/GPT 폴백 구현 |\n| 대용량 PDF 처리 실패 | 중간 | 중간 | 페이지 분할 처리 |\n| 응답 시간 초과 | 중간 | 중간 | 프로그레시브 로딩 |\n| 벡터 DB 성능 저하 | 낮음 | 낮음 | 인덱스 최적화 |\n\n### 6.2 프로젝트 리스크\n\n| 리스크 | 영향도 | 발생확률 | 대응 방안 |\n|--------|--------|----------|-----------|\n| 1인 개발 일정 지연 | 높음 | 중간 | MVP 범위 축소 |\n| 요구사항 변경 | 중간 | 높음 | 애자일 접근, 주간 리뷰 |\n| 서버 리소스 부족 | 중간 | 낮음 | 클라우드 이전 검토 |\n\n## 7. 향후 확장 계획\n\n### 7.1 Phase 2 (2개월 후)\n- 두레이 메신저 통합\n- 고급 분석 기능 (트렌드, 비교)\n- 멀티 언어 지원 (영문 문서)\n\n### 7.2 Phase 3 (6개월 후)\n- KIIPS ERP 연동\n- 자동 리포트 생성\n- AI 기반 투자 인사이트 제공\n\n### 7.3 확장성 고려사항\n```python\n# 메시징 인터페이스 추상화\nclass MessageInterface(ABC):\n    @abstractmethod\n    async def send_message(self, message: str) -> str:\n        pass\n\nclass WebInterface(MessageInterface):\n    # 현재 구현\n\nclass DoorayInterface(MessageInterface):\n    # 향후 구현\n\nclass KakaoWorkInterface(MessageInterface):\n    # 향후 구현\n```\n\n## 8. 성공 기준\n\n### 8.1 단기 (1개월)\n- [ ] 5명 이상의 활성 사용자\n- [ ] 일일 50개 이상의 질문 처리\n- [ ] 평균 만족도 4.0/5.0 이상\n\n### 8.2 중기 (3개월)\n- [ ] 전 직원 사용\n- [ ] 월 API 비용 10만원 이내 유지\n- [ ] 두레이 통합 완료\n\n### 8.3 장기 (6개월)\n- [ ] 250개 기업 커버리지\n- [ ] 자동화된 인사이트 제공\n- [ ] ROI 증명 (시간 절감 측정)\n\n---\n\n## 부록 A: 주요 기술 결정 사항\n\n### A.1 Claude 선택 이유\n- PDF 네이티브 지원\n- 한국어 성능 우수\n- 컨텍스트 윈도우 크기 (200K)\n- 비용 대비 성능\n\n### A.2 ChromaDB 선택 이유\n- 설치 및 사용 간편\n- 로컬 실행 가능\n- 한국어 임베딩 지원\n- 충분한 성능\n\n### A.3 FastAPI 선택 이유\n- 빠른 개발 속도\n- 자동 API 문서화\n- 비동기 지원\n- Python 생태계 활용\n\n---\n\n**문서 끝**",
      "writedAt": "2025-07-25T05:58:09.081Z"
    },
    {
      "type": "architecture",
      "content": "# 기술 요구사항 명세서 (TRD)\n\n## 1. Executive Technical Summary\n- **프로젝트 개요**: 본 프로젝트는 투자팀이 포트폴리오 기업의 재무 및 뉴스 정보를 신속하게 조회하고 분석할 수 있도록 지원하는 AI 기반 대화형 Q&A 챗봇을 구축하는 것을 목표로 합니다. 아키텍처는 React 프론트엔드와 FastAPI 백엔드를 중심으로 구성되며, Retrieval-Augmented Generation (RAG) 패턴을 활용하여 PDF 문서와 뉴스 데이터를 기반으로 정확한 답변을 생성합니다.\n- **핵심 기술 스택**: 프론트엔드는 React와 Tailwind CSS, 백엔드는 Python FastAPI를 사용합니다. 데이터 저장은 PostgreSQL(메타데이터), ChromaDB(벡터), Redis(캐시)를 활용하며, 핵심 AI 기능은 Anthropic의 Claude API를 통해 구현합니다.\n- **주요 기술 목표**: 평균 응답 시간 3초 이내, 월 API 비용 10만원 미만, 시스템 가용성 99% 달성을 목표로 합니다. 또한, 향후 250개 기업까지 확장 가능한 구조를 설계합니다.\n- **핵심 기술 가정**: 사용자의 질의응답은 주로 Claude API를 통해 처리되며, API의 성능과 안정성이 시스템 전체 품질에 직접적인 영향을 미칩니다. 초기 데이터(PDF, 뉴스)는 로컬 파일 시스템과 데이터베이스에 저장 및 관리되는 것을 전제로 합니다.\n\n## 2. 기술 스택\n\n| 카테고리 | 기술 / 라이브러리 | 선정 사유 |\n| --- | --- | --- |\n| **프론트엔드** | React.js, Vite | 선언적 UI와 컴포넌트 기반 아키텍처로 복잡한 채팅 인터페이스를 효율적으로 구축할 수 있습니다. Vite는 빠른 개발 서버와 빌드 속도를 제공합니다. |\n| **UI/스타일링** | Tailwind CSS | 유틸리티-우선 접근 방식으로 신속한 프로토타이핑과 일관된 디자인 시스템 적용이 용이합니다. |\n| **백엔드 프레임워크** | FastAPI (Python) | 비동기 처리를 지원하여 I/O 바운드 작업(API 호출, DB 조회)이 많은 챗봇 특성에 적합하며, 자동 API 문서 생성으로 개발 생산성을 높입니다. |\n| **데이터베이스 (메타데이터)** | PostgreSQL | 신뢰성 높은 관계형 데이터베이스로, 문서 및 사용자 메타데이터를 정형화하여 관리하기에 적합하며 향후 복잡한 쿼리 및 확장에 용이합니다. |\n| **벡터 데이터베이스** | ChromaDB | 설치와 사용이 간편한 경량 벡터 DB로, MVP 단계에서 RAG 구현을 위한 임베딩 벡터 검색 기능을 빠르게 구축할 수 있습니다. |\n| **캐시** | Redis | 인메모리 데이터 저장소로, 반복적인 API 응답과 검색 결과를 캐싱하여 시스템 응답 속도를 향상시키고 API 비용을 절감하는 데 필수적입니다. |\n| **AI/LLM** | Claude 3 API | 한국어 처리 능력이 우수하고, 대용량 PDF 문서 분석에 강점을 보여 본 프로젝트의 핵심 요구사항인 문서 기반 질의응답에 가장 적합합니다. |\n| **인프라/배포** | Docker, Nginx, Gunicorn | 컨테이너화를 통해 개발 및 배포 환경을 일치시키고, Nginx와 Gunicorn 조합은 안정적인 Python 웹 애플리케이션 서빙을 위한 표준 구성입니다. |\n\n## 3. 시스템 아키텍처 설계\n\n### 최상위 구성 요소\n- **프론트엔드 (React Web UI)**: 사용자가 질문을 입력하고 답변을 확인하는 웹 기반 채팅 인터페이스입니다. API 서버와 통신하여 데이터를 주고받으며, 차트 시각화를 담당합니다.\n- **웹 서버 (Nginx)**: 리버스 프록시 역할을 수행하며, 클라이언트의 요청을 백엔드 애플리케이션 서버로 전달합니다. 정적 파일 서빙 및 로드 밸런싱을 담당합니다.\n- **백엔드 (FastAPI Server)**: 비즈니스 로직의 핵심으로, 사용자 요청 처리, 데이터베이스 및 외부 API 연동, RAG 파이프라인 실행 등 모든 서버 사이드 로직을 총괄합니다.\n- **데이터 저장소**:\n    - **PostgreSQL**: 문서, 뉴스, 사용자 등의 메타데이터를 저장합니다.\n    - **ChromaDB**: 문서 내용을 벡터로 변환하여 저장하고, 의미 기반 검색을 지원합니다.\n    - **Redis**: 자주 사용되는 데이터나 API 응답을 캐싱하여 성능을 향상시킵니다.\n    - **File System**: 원본 PDF 문서 파일을 저장하고 관리합니다.\n- **외부 서비스 (Claude API)**: 백엔드에서 증강된 프롬프트(Augmented Prompt)를 전달받아, 자연어 답변을 생성하는 핵심 LLM 서비스입니다.\n\n### 최상위 컴포넌트 상호작용 다이어그램\n\n```mermaid\ngraph TD\n    subgraph 사용자 환경\n        A[React 웹 UI]\n    end\n\n    subgraph 서버 인프라\n        B[Nginx 리버스 프록시]\n        C[FastAPI 백엔드 서버]\n        D[PostgreSQL<br/>(메타데이터)]\n        E[Redis<br/>(캐시)]\n        F[ChromaDB<br/>(벡터 DB)]\n        G[로컬 파일 시스템<br/>(PDF 원본)]\n    end\n\n    subgraph 외부 서비스\n        H[Claude API]\n    end\n\n    A -- HTTPS --> B\n    B -- HTTP --> C\n\n    C -- RAG 파이프라인 --> H\n    C -- CRUD --> D\n    C -- 캐시 조회/저장 --> E\n    C -- 벡터 검색 --> F\n    C -- 파일 읽기 --> G\n```\n\n- **사용자 요청 흐름**: 사용자는 React UI에서 질문을 입력하고, 이 요청은 Nginx를 통해 FastAPI 백엔드 서버로 전달됩니다.\n- **백엔드 처리**: FastAPI 서버는 요청 유형에 따라 PostgreSQL에서 메타데이터를 조회하고, ChromaDB에서 관련 문서 벡터를 검색합니다.\n- **RAG 및 응답 생성**: 검색된 문서 내용을 바탕으로 프롬프트를 구성하여 Claude API에 전달하고, 생성된 답변을 받습니다. Redis 캐시를 우선적으로 확인하여 API 호출을 최소화합니다.\n- **응답 반환**: 최종적으로 가공된 답변(텍스트, 출처, 차트 데이터 등)을 다시 Nginx를 거쳐 React UI로 전송하여 사용자에게 표시합니다.\n\n### 코드 구성 및 규칙\n**도메인 주도 구성 전략**\n- **도메인 분리**: 코드를 비즈니스 도메인(예: `chat`, `documents`, `users`, `auth`) 중심으로 구성하여 응집도를 높이고 결합도를 낮춥니다.\n- **계층 기반 아키텍처**: 각 도메인 내부는 API(라우터), 서비스(비즈니스 로직), 리포지토리(데이터 접근) 계층으로 분리하여 관심사를 명확히 합니다.\n- **공유 컴포넌트**: 여러 도메인에서 공통으로 사용되는 유틸리티, 설정, 기본 스키마 등은 `core` 또는 `shared` 모듈에 배치합니다.\n\n**범용 파일 및 폴더 구조 (FastAPI 백엔드 기준)**\n```\n/\n├── app/\n│   ├── __init__.py\n│   ├── main.py             # FastAPI 앱 초기화 및 미들웨어 설정\n│   ├── api/                # API 엔드포인트 (라우터)\n│   │   ├── __init__.py\n│   │   ├── endpoints/\n│   │   │   ├── chat.py\n│   │   │   ├── documents.py\n│   │   │   └── auth.py\n│   │   └── deps.py         # 의존성 주입\n│   ├── core/               # 핵심 로직 및 설정\n│   │   ├── __init__.py\n│   │   ├── config.py       # 환경 변수 및 설정\n│   │   └── security.py     # 인증/보안 관련 유틸\n│   ├── crud/               # 데이터베이스 CRUD 작업 (리포지토리)\n│   │   ├── __init__.py\n│   │   └── ...\n│   ├── schemas/            # Pydantic 데이터 모델\n│   │   ├── __init__.py\n│   │   └── ...\n│   ├── services/           # 비즈니스 로직\n│   │   ├── __init__.py\n│   │   ├── chat_service.py\n│   │   └── rag_pipeline.py\n│   └── db/                 # 데이터베이스 세션 및 초기화\n│       ├── __init__.py\n│       └── session.py\n├── data/                   # 데이터 파일 (PRD 구조 참조)\n│   └── ...\n├── tests/                  # 테스트 코드\n└── docker-compose.yml      # Docker 설정\n```\n\n### 데이터 흐름 및 통신 패턴\n- **클라이언트-서버 통신**: 프론트엔드와 백엔드는 JSON 형식을 사용하는 RESTful API를 통해 통신합니다. 모든 통신은 HTTPS로 암호화됩니다.\n- **데이터베이스 상호작용**: FastAPI는 SQLAlchemy ORM을 사용하여 PostgreSQL과 상호작용하며, 비동기 세션을 통해 효율적인 DB 접근을 관리합니다.\n- **외부 서비스 통합**: 백엔드의 `rag_pipeline` 서비스가 Claude API와의 통신을 전담합니다. API 요청/응답 로직을 별도 모듈로 추상화하여 관리하고, 비용 및 사용량 모니터링 로직을 포함합니다.\n- **실시간 통신**: 현재는 요청-응답 모델을 사용합니다. 향후 실시간 스트리밍 답변이 필요할 경우, WebSocket 또는 Server-Sent Events(SSE)를 도입하여 응답을 점진적으로 표시할 수 있습니다.\n- **데이터 동기화 (RAG 흐름)**:\n    1.  사용자 질문 수신\n    2.  질문 임베딩 생성\n    3.  ChromaDB에서 유사도 높은 문서 청크(chunk) 검색\n    4.  검색된 청크와 원본 질문을 조합하여 프롬프트 생성\n    5.  생성된 프롬프트를 Claude API로 전송\n    6.  LLM 답변 수신 후, 출처 정보와 함께 가공하여 사용자에게 반환\n\n## 4. 성능 및 최적화 전략\n- **응답 캐싱**: Redis를 활용하여 동일한 질문에 대한 LLM 응답과 자주 조회되는 문서 검색 결과를 캐싱합니다. 이를 통해 API 비용을 절감하고 평균 응답 시간을 3초 이내로 유지합니다.\n- **LLM 라우팅 최적화**: 질문의 유형과 복잡도를 분석하여 Claude 3의 Opus, Sonnet, Haiku 모델을 동적으로 선택하는 라우팅 로직을 구현합니다. 단순 조회는 비용이 저렴한 Haiku를, 복잡한 분석은 Opus를 사용하여 비용 대비 성능을 최적화합니다.\n- **비동기 처리 활용**: FastAPI의 비동기 기능을 최대한 활용하여 외부 API 호출, 데이터베이스 조회 등 I/O 바운드 작업을 병렬로 처리함으로써 전체 시스템의 처리량과 응답성을 높입니다.\n- **데이터베이스 인덱싱**: PostgreSQL 테이블의 `company_name`, `published_date`, `year` 등 검색 조건으로 자주 사용되는 컬럼에 인덱스를 생성하여 쿼리 성능을 최적화합니다.\n\n## 5. 구현 로드맵 및 마일스톤\n### 1단계: 기반 구축 (MVP 구현, 2주)\n- **핵심 인프라**: Docker 기반 개발 환경, PostgreSQL, Redis, ChromaDB 기본 설정 및 연동을 완료합니다.\n- **필수 기능**: Claude API를 연동한 기본 채팅 기능, PDF 문서 검색 및 분석, 뉴스 메타데이터 검색 기능을 구현합니다.\n- **기본 보안**: API 통신을 위한 기본 설정만 적용합니다.\n- **개발 환경**: FastAPI 프로젝트 구조 설정 및 Git 리포지토리 생성을 완료합니다.\n- **예상 기간**: 2주\n\n### 2단계: 기능 강화 (3-4주)\n- **고급 기능**: 사용자 로그인 및 인증 시스템(JWT 기반), 재무 데이터 차트 시각화(Chart.js 연동), 검색 결과 캐싱 로직을 구현합니다.\n- **성능 최적화**: 쿼리 최적화 및 응답 캐싱을 통해 시스템 성능을 개선합니다.\n- **보안 강화**: HTTPS 적용 및 민감 정보 암호화 저장 방안을 마련합니다.\n- **모니터링 구현**: 기본적인 API 요청/응답 로깅 시스템을 구축합니다.\n- **예상 기간**: 2주\n\n### 3단계: 확장 및 최적화 (2개월 후)\n- **확장성 구현**: 두레이 메신저 연동을 위한 인터페이스 추상화 및 구현을 진행합니다.\n- **고급 통합**: KIIPS ERP 연동을 위한 아키텍처를 설계하고 프로토타입을 개발합니다.\n- **엔터프라이즈 기능**: 자동 리포트 생성, 다중 문서 비교 분석 등 고급 분석 기능을 추가합니다.\n- **규정 준수 및 감사**: 내부 SSO 연동 및 접근 제어 정책을 강화합니다.\n- **예상 기간**: 4주 이상\n\n## 6. 리스크 평가 및 완화 전략\n### 기술 리스크 분석\n- **기술 리스크**: Claude API 장애 또는 성능 저하 발생 시, 시스템의 핵심 기능이 마비될 수 있습니다.\n    - **완화 전략**: Gemini 등 대체 LLM으로 전환할 수 있는 폴백(Fallback) 로직을 구현하고, API 상태를 주기적으로 모니터링합니다.\n- **성능 리스크**: 포트폴리오 기업 수가 250개까지 증가함에 따라 벡터 DB 검색 속도 저하 또는 대용량 PDF 처리 시간이 길어질 수 있습니다.\n    - **완화 전략**: ChromaDB 인덱스를 최적화하고, 필요시 관리형 벡터 DB로의 전환을 검토합니다. 대용량 PDF는 처리 전 페이지 단위로 분할하는 파이프라인을 구축합니다.\n- **보안 리스크**: 내부 재무 정보 등 민감 데이터를 다루므로, 비인가 접근 시 정보 유출의 위험이 있습니다.\n    - **완화 전략**: 강력한 사용자 인증(향후 SSO 연동)을 적용하고, 데이터베이스 접근 제어 및 모든 통신 구간 암호화를 의무화합니다.\n- **통합 리스크**: 향후 두레이, ERP 등 외부 시스템 연동 시 API 사양 변경이나 호환성 문제가 발생할 수 있습니다.\n    - **완화 전략**: 외부 연동 모듈을 추상화된 인터페이스 기반으로 설계하여 특정 시스템에 대한 의존도를 낮추고, 변경에 유연하게 대응할 수 있도록 합니다.\n\n### 프로젝트 납품 리스크\n- **일정 리스크**: 1인 개발로 진행되므로, 예상치 못한 기술적 난관이나 요구사항 변경 시 일정 지연 가능성이 높습니다.\n    - **대응 계획**: MVP 범위를 명확히 하고, 주간 단위로 진행 상황을 공유하며 위험 요소를 조기에 식별합니다. 일정 지연이 불가피할 경우, 우선순위가 낮은 기능(Could Have)부터 제외하는 방향으로 범위를 조정합니다.\n- **자원 리스크**: 특정 기술(LLM, 벡터 DB)에 대한 전문성이 부족할 경우 개발 속도가 저하될 수 있습니다.\n    - **대응 계획**: 커뮤니티와 공식 문서를 적극 활용하고, 복잡한 문제는 외부 전문가 자문을 구하는 방안을 고려합니다.\n- **품질 리스크**: 빠른 개발 속도를 우선시하다 보면 테스트 커버리지가 부족해져 배포 후 버그가 발생할 수 있습니다.\n    - **대응 계획**: 핵심 기능(RAG 파이프라인, 인증)에 대한 단위 테스트 및 통합 테스트 코드를 작성하여 코드 품질을 최소한으로 보장합니다.\n- **배포 리스크**: 개발 환경과 운영 환경의 차이로 인해 배포 시 예상치 못한 문제가 발생할 수 있습니다.\n    - **대응 계획**: Docker를 사용하여 환경을 일치시키고, 배포 전 스테이징 환경에서 충분한 테스트를 거칩니다. 배포 프로세스를 스크립트로 자동화하여 실수를 줄입니다.",
      "writedAt": "2025-07-25T05:58:09.082Z"
    },
    {
      "type": "guideline",
      "content": "# Investment Portfolio Q&A Chatbot: Code Guideline\n\n## 1. Project Overview\n\nThis document outlines the coding standards and best practices for the \"Investment Portfolio Intelligence Assistant\" project. This AI-powered conversational Q&A chatbot aims to provide investment teams with rapid access to financial and news information on portfolio companies. The system leverages a React.js frontend, a FastAPI backend, and a Retrieval-Augmented Generation (RAG) pattern utilizing Anthropic's Claude API, PostgreSQL, ChromaDB, and Redis.\n\nKey architectural decisions include:\n*   **Decoupled Frontend/Backend**: React.js for UI, FastAPI for business logic.\n*   **RAG Pattern**: Claude API for LLM, ChromaDB for vector search, PostgreSQL for metadata.\n*   **Performance Optimization**: Redis for caching, asynchronous processing in FastAPI.\n*   **Scalability**: Dockerized services, domain-driven backend structure.\n\n## 2. Core Principles\n\n1.  **Readability**: Code MUST be easily understood by other developers.\n2.  **Maintainability**: Code MUST be simple to modify, debug, and extend.\n3.  **Testability**: Code MUST be designed for easy and comprehensive testing.\n4.  **Performance**: Code MUST be optimized for speed and resource efficiency, especially for I/O operations.\n5.  **Security**: Code MUST adhere to security best practices, protecting sensitive data.\n\n## 3. Language-Specific Guidelines\n\n### 3.1 Python (FastAPI Backend)\n\n#### File Organization and Directory Structure\n*   **MUST**: Organize code by business domain within the `app/` directory.\n    ```\n    app/\n    ├── api/                # API endpoints (routers)\n    │   ├── endpoints/\n    │   │   ├── chat.py\n    │   │   ├── documents.py\n    │   │   └── auth.py\n    │   └── deps.py         # Dependency injection utilities\n    ├── core/               # Core configurations, utilities, security\n    │   ├── config.py\n    │   └── security.py\n    ├── crud/               # Database CRUD operations (repositories)\n    │   ├── chat_crud.py\n    │   └── document_crud.py\n    ├── schemas/            # Pydantic models for request/response/database\n    │   ├── chat_schemas.py\n    │   └── document_schemas.py\n    ├── services/           # Business logic, external API calls, RAG pipeline\n    │   ├── chat_service.py\n    │   ├── document_service.py\n    │   └── rag_pipeline.py\n    ├── db/                 # Database session management\n    │   └── session.py\n    └── main.py             # FastAPI app initialization\n    ```\n*   **MUST NOT**: Create monolithic files containing multiple unrelated domains or layers.\n\n#### Import/Dependency Management\n*   **MUST**: Use absolute imports from the `app` root.\n    ```python\n    # MUST: Absolute import\n    from app.services.chat_service import ChatService\n    from app.schemas.chat_schemas import ChatRequest\n    ```\n*   **MUST NOT**: Use relative imports that make code less portable or harder to refactor.\n    ```python\n    # MUST NOT: Relative import\n    # from ..services.chat_service import ChatService\n    ```\n*   **MUST**: Explicitly declare dependencies using FastAPI's `Depends` for better testability and maintainability.\n    ```python\n    # MUST: Use FastAPI's Depends for dependency injection\n    from fastapi import Depends, APIRouter\n    from app.services.chat_service import ChatService\n\n    router = APIRouter()\n\n    @router.post(\"/chat/\")\n    async def create_chat_completion(\n        request: ChatRequest,\n        chat_service: ChatService = Depends(ChatService)\n    ):\n        return await chat_service.process_query(request.question)\n    ```\n\n#### Error Handling Patterns\n*   **MUST**: Use FastAPI's `HTTPException` for API-level errors.\n    ```python\n    # MUST: Raise HTTPException for API errors\n    from fastapi import HTTPException, status\n\n    async def get_document(doc_id: int):\n        doc = await document_crud.get(doc_id)\n        if not doc:\n            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Document not found\")\n        return doc\n    ```\n*   **MUST**: Implement custom exception handlers for specific application errors.\n*   **MUST**: Log detailed error information for debugging.\n    ```python\n    # MUST: Log errors\n    import logging\n    logger = logging.getLogger(__name__)\n\n    try:\n        # Some risky operation\n        result = 1 / 0\n    except ZeroDivisionError as e:\n        logger.error(f\"Calculation error: {e}\", exc_info=True)\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=\"Internal server error\")\n    ```\n\n### 3.2 JavaScript/TypeScript (React.js Frontend)\n\n#### File Organization and Directory Structure\n*   **MUST**: Organize components and hooks by feature or domain.\n    ```\n    src/\n    ├── components/         # Reusable UI components (e.g., Button, Modal)\n    │   ├── common/\n    │   └── layout/\n    ├── features/           # Feature-specific components, hooks, and logic\n    │   ├── chat/\n    │   │   ├── components/ # Chat-specific components (e.g., ChatWindow, MessageBubble)\n    │   │   ├── hooks/      # Chat-specific hooks (e.g., useChat)\n    │   │   └── ChatPage.jsx\n    │   ├── auth/\n    │   │   └── LoginPage.jsx\n    │   └── documents/\n    ├── hooks/              # Global reusable hooks (e.g., useAuth)\n    ├── services/           # API interaction logic\n    │   └── api.js\n    ├── contexts/           # React Context API providers\n    ├── utils/              # General utility functions\n    ├── App.jsx\n    └── main.jsx\n    ```\n*   **MUST NOT**: Dump all components into a single `components/` directory without further organization.\n\n#### Import/Dependency Management\n*   **MUST**: Use absolute imports configured via `jsconfig.json` or `tsconfig.json` for cleaner paths.\n    ```javascript\n    // jsconfig.json or tsconfig.json\n    {\n      \"compilerOptions\": {\n        \"baseUrl\": \"src\"\n      }\n    }\n\n    // MUST: Absolute import\n    import { Button } from 'components/common/Button';\n    import { useChat } from 'features/chat/hooks/useChat';\n    ```\n*   **MUST NOT**: Use deeply nested relative imports.\n\n#### Error Handling Patterns\n*   **MUST**: Use `try-catch` blocks for asynchronous operations (e.g., API calls) and display user-friendly error messages.\n    ```javascript\n    // MUST: Handle errors in async operations\n    import { useState } from 'react';\n    import api from 'services/api';\n\n    function ChatInput() {\n      const [error, setError] = useState(null);\n\n      const handleSubmit = async (question) => {\n        try {\n          setError(null);\n          const response = await api.post('/chat', { question });\n          // Process response\n        } catch (err) {\n          console.error(\"Failed to send message:\", err);\n          setError(\"Failed to send message. Please try again.\");\n        }\n      };\n\n      return (\n        <div>\n          {error && <div className=\"text-red-500\">{error}</div>}\n          <button onClick={() => handleSubmit(\"Hello\")}>Send</button>\n        </div>\n      );\n    }\n    ```\n*   **MUST**: Centralize error logging or reporting (e.g., to a monitoring service) if applicable.\n\n## 4. Code Style Rules\n\n### MUST Follow:\n\n*   **Consistent Naming Conventions**:\n    *   **Python**: `snake_case` for variables, functions, and modules. `PascalCase` for classes. `UPPER_SNAKE_CASE` for constants.\n    *   **JavaScript/TypeScript**: `camelCase` for variables and functions. `PascalCase` for React components and classes. `UPPER_SNAKE_CASE` for global constants.\n    *   **Rationale**: Ensures immediate recognition of code elements and improves readability.\n\n    ```python\n    # MUST: Python naming\n    class ChatService:\n        MAX_RETRIES = 3\n        def process_query(self, user_question: str):\n            pass\n    ```\n    ```javascript\n    // MUST: JavaScript naming\n    const maxRetries = 3;\n    function ChatInput() { /* ... */ }\n    class ApiService { /* ... */ }\n    ```\n\n*   **Type Hinting (Python) / TypeScript (JavaScript)**:\n    *   **MUST**: Use type hints for all function arguments, return values, and class attributes in Python.\n    *   **MUST**: Use TypeScript for all frontend code to ensure type safety.\n    *   **Rationale**: Improves code clarity, enables static analysis, and reduces runtime errors.\n\n    ```python\n    # MUST: Python type hints\n    def calculate_revenue(sales: float, price_per_unit: float) -> float:\n        return sales * price_per_unit\n    ```\n    ```typescript\n    // MUST: TypeScript types\n    interface ChatMessage {\n      id: string;\n      text: string;\n      sender: 'user' | 'ai';\n    }\n\n    const sendMessage = (message: ChatMessage): void => { /* ... */ };\n    ```\n\n*   **Docstrings/Comments**:\n    *   **MUST**: Provide clear and concise docstrings for all modules, classes, and functions in Python (Google style).\n    *   **MUST**: Add comments for complex logic or non-obvious code sections in both Python and JavaScript.\n    *   **Rationale**: Essential for understanding code purpose and usage, especially in a team environment.\n\n    ```python\n    # MUST: Python Docstring\n    def get_financial_report(company_name: str, year: int) -> dict:\n        \"\"\"Retrieves the financial report for a given company and year.\n\n        Args:\n            company_name: The name of the company.\n            year: The fiscal year of the report.\n\n        Returns:\n            A dictionary containing the financial report data.\n        \"\"\"\n        # ... implementation ...\n    ```\n\n*   **Pydantic for Data Validation**:\n    *   **MUST**: Use Pydantic models for all request bodies, response models, and database schemas in FastAPI.\n    *   **Rationale**: Provides robust data validation, serialization, and automatic documentation.\n\n    ```python\n    # MUST: Use Pydantic for data validation\n    from pydantic import BaseModel\n\n    class ChatRequest(BaseModel):\n        question: str\n        context: dict | None = None\n\n    class ChatResponse(BaseModel):\n        answer: str\n        sources: list[str]\n    ```\n\n*   **Asynchronous Programming**:\n    *   **MUST**: Use `async/await` for all I/O-bound operations (database queries, external API calls, file operations) in FastAPI.\n    *   **Rationale**: Prevents blocking the event loop, improving concurrency and overall system responsiveness.\n\n    ```python\n    # MUST: Use async/await for I/O operations\n    from sqlalchemy.ext.asyncio import AsyncSession\n    from app.crud.document_crud import DocumentCRUD\n\n    async def get_document_by_id(db: AsyncSession, doc_id: int):\n        return await DocumentCRUD(db).get(doc_id)\n    ```\n\n### MUST NOT Do:\n\n*   **Monolithic Files/Modules**:\n    *   **MUST NOT**: Create huge, multi-responsibility modules or files that handle too many unrelated concerns.\n    *   **Rationale**: Violates Single Responsibility Principle, makes code hard to navigate, test, and maintain.\n\n    ```python\n    # MUST NOT: Monolithic file (avoid combining unrelated logic)\n    # chat_and_document_and_user_service.py\n    # This file should be split into chat_service.py, document_service.py, user_service.py\n    ```\n\n*   **Complex State Management (Frontend)**:\n    *   **MUST NOT**: Introduce overly complex state management patterns (e.g., Redux) unless absolutely necessary for global, deeply shared state. Prefer React Context API and local component state for most cases.\n    *   **Rationale**: Increases boilerplate and learning curve for a project of this scale. Context API is sufficient for the current requirements.\n\n    ```javascript\n    // MUST NOT: Over-engineer state management for simple cases\n    // Avoid introducing Redux/Zustand/Jotai for simple chat state if Context API suffices.\n    // Use React Context API for global state like user authentication or theme.\n    ```\n\n*   **Hardcoding Sensitive Information**:\n    *   **MUST NOT**: Hardcode API keys, database credentials, or any other sensitive information directly in the code.\n    *   **Rationale**: Major security vulnerability. Use environment variables (e.g., `os.getenv` in Python, `import.meta.env` in Vite) or a secure configuration management system.\n\n    ```python\n    # MUST NOT: Hardcode API key\n    # CLAUDE_API_KEY = \"sk-...\"\n\n    # MUST: Use environment variables\n    import os\n    CLAUDE_API_KEY = os.getenv(\"CLAUDE_API_KEY\")\n    ```\n\n*   **Ignoring Exceptions**:\n    *   **MUST NOT**: Use empty `except` blocks or `pass` in `except` blocks, suppressing errors without logging or handling them.\n    *   **Rationale**: Makes debugging impossible and hides critical issues.\n\n    ```python\n    # MUST NOT: Suppress exceptions\n    # try:\n    #     some_risky_operation()\n    # except Exception:\n    #     pass # This is bad!\n\n    # MUST: Handle or log exceptions appropriately\n    try:\n        some_risky_operation()\n    except SpecificException as e:\n        logger.error(f\"Error during operation: {e}\")\n        # Re-raise, return error, or provide fallback\n    ```\n\n## 5. Architecture Patterns\n\n### Component/Module Structure Guidelines\n\n*   **Domain-Driven Design (Backend)**:\n    *   **MUST**: Structure the backend around business domains (e.g., `chat`, `documents`, `auth`). Each domain should have its own `api/endpoints`, `services`, `crud`, and `schemas` subdirectories.\n    *   **Rationale**: Promotes high cohesion and low coupling, making the codebase easier to understand, develop, and scale independently.\n\n*   **Layered Architecture (Backend)**:\n    *   **MUST**: Maintain clear separation between API (endpoints), Service (business logic), and Repository (CRUD/data access) layers.\n    *   **Rationale**: Each layer has a distinct responsibility, simplifying testing and allowing changes in one layer without affecting others.\n\n    ```python\n    # app/api/endpoints/chat.py (API Layer)\n    from fastapi import APIRouter, Depends\n    from app.schemas.chat_schemas import ChatRequest, ChatResponse\n    from app.services.chat_service import ChatService\n\n    router = APIRouter()\n\n    @router.post(\"/chat\", response_model=ChatResponse)\n    async def chat_endpoint(request: ChatRequest, service: ChatService = Depends()):\n        return await service.process_query(request.question, request.context)\n\n    # app/services/chat_service.py (Service Layer - Business Logic)\n    from app.services.rag_pipeline import RAGPipeline\n    from app.crud.chat_crud import ChatCRUD\n    from app.schemas.chat_schemas import ChatResponse\n    from sqlalchemy.ext.asyncio import AsyncSession\n\n    class ChatService:\n        def __init__(self, db_session: AsyncSession = Depends(get_db_session)):\n            self.rag_pipeline = RAGPipeline(db_session)\n            self.chat_crud = ChatCRUD(db_session)\n\n        async def process_query(self, question: str, context: dict) -> ChatResponse:\n            answer, sources = await self.rag_pipeline.generate_response(question, context)\n            await self.chat_crud.save_chat_history(question, answer, sources)\n            return ChatResponse(answer=answer, sources=sources)\n\n    # app/crud/chat_crud.py (Repository Layer - Data Access)\n    from sqlalchemy.ext.asyncio import AsyncSession\n    from app.db.models import ChatHistory\n\n    class ChatCRUD:\n        def __init__(self, db_session: AsyncSession):\n            self.db = db_session\n\n        async def save_chat_history(self, question: str, answer: str, sources: list[str]):\n            chat_entry = ChatHistory(question=question, answer=answer, context={\"sources\": sources})\n            self.db.add(chat_entry)\n            await self.db.commit()\n            await self.db.refresh(chat_entry)\n            return chat_entry\n    ```\n\n### Data Flow Patterns\n\n*   **Request-Response (RESTful API)**:\n    *   **MUST**: All client-server communication MUST follow a RESTful request-response pattern using JSON payloads.\n    *   **Rationale**: Standard, stateless, and widely understood pattern for web services.\n    *   **Example**: `POST /api/chat` for sending questions, `GET /api/news/search` for news retrieval.\n\n*   **RAG Pipeline**:\n    *   **MUST**: Implement the RAG pipeline within the `rag_pipeline.py` service. This service is responsible for:\n        1.  Receiving user query.\n        2.  Generating embeddings for the query.\n        3.  Retrieving relevant document chunks from ChromaDB.\n        4.  Constructing an augmented prompt.\n        5.  Calling the Claude API.\n        6.  Parsing and returning the LLM response.\n    *   **Rationale**: Centralizes the core AI logic, making it maintainable and testable.\n\n    ```python\n    # app/services/rag_pipeline.py\n    from app.crud.document_crud import DocumentCRUD\n    from app.core.llm import LLMClient # Abstraction for Claude API\n    from app.core.embedding import EmbeddingClient # Abstraction for Embedding model\n\n    class RAGPipeline:\n        def __init__(self, db_session: AsyncSession):\n            self.document_crud = DocumentCRUD(db_session)\n            self.llm_client = LLMClient()\n            self.embedding_client = EmbeddingClient()\n\n        async def generate_response(self, question: str, context: dict | None = None) -> tuple[str, list[str]]:\n            # 1. Generate query embedding\n            query_embedding = await self.embedding_client.embed(question)\n\n            # 2. Retrieve relevant documents from ChromaDB (via document_crud)\n            relevant_docs = await self.document_crud.search_vector_db(query_embedding, top_k=5)\n            doc_contents = [doc.content for doc in relevant_docs]\n            sources = [doc.source_id for doc in relevant_docs] # Assuming source_id is available\n\n            # 3. Construct augmented prompt\n            augmented_prompt = self._build_prompt(question, doc_contents)\n\n            # 4. Call LLM API (with optional model routing)\n            answer = await self.llm_client.generate_text(augmented_prompt, question_type=\"complex_analysis\")\n\n            return answer, sources\n\n        def _build_prompt(self, question: str, documents: list[str]) -> str:\n            # MUST: Define clear prompt templates\n            context_str = \"\\n\".join([f\"Document {i+1}: {doc}\" for i, doc in enumerate(documents)])\n            return f\"\"\"You are an intelligent assistant for investment teams.\n            Based on the following documents, answer the user's question.\n            If the answer is not in the documents, state that you don't have enough information.\n\n            Documents:\n            {context_str}\n\n            User Question: {question}\n            \"\"\"\n    ```\n\n### State Management Conventions (React Frontend)\n\n*   **MUST**: Prefer local component state (`useState`) for UI-specific, ephemeral data.\n*   **MUST**: Use `useContext` for global or shared state that needs to be accessed by multiple, non-directly related components (e.g., authentication status, user preferences).\n*   **MUST**: Use custom hooks (`useReducer`, `useEffect`) to encapsulate complex state logic and side effects, promoting reusability.\n*   **Rationale**: Keeps state management simple and predictable for the project's scale, avoiding over-engineering.\n\n    ```javascript\n    // MUST: Use useState for local component state\n    import React, { useState } from 'react';\n\n    function MessageInput() {\n      const [message, setMessage] = useState('');\n      const handleSend = () => { /* ... */ };\n\n      return (\n        <input\n          type=\"text\"\n          value={message}\n          onChange={(e) => setMessage(e.target.value)}\n        />\n      );\n    }\n\n    // MUST: Use useContext for global state\n    // src/contexts/AuthContext.jsx\n    import React, { createContext, useContext, useState } from 'react';\n\n    const AuthContext = createContext(null);\n\n    export const AuthProvider = ({ children }) => {\n      const [user, setUser] = useState(null);\n      // ... login/logout functions ...\n      return (\n        <AuthContext.Provider value={{ user, setUser }}>\n          {children}\n        </AuthContext.Provider>\n      );\n    };\n\n    export const useAuth = () => useContext(AuthContext);\n\n    // In a component:\n    // import { useAuth } from 'contexts/AuthContext';\n    // const { user } = useAuth();\n    ```\n\n### API Design Standards (FastAPI)\n\n*   **MUST**: Follow RESTful principles for API endpoint design (e.g., `GET /resources`, `POST /resources`, `GET /resources/{id}`).\n*   **MUST**: Use clear, descriptive, and pluralized resource names in URLs.\n*   **MUST**: Use appropriate HTTP status codes for responses (e.g., 200 OK, 201 Created, 400 Bad Request, 404 Not Found, 500 Internal Server Error).\n*   **MUST**: Provide meaningful error messages in JSON format for client consumption.\n*   **MUST**: Implement authentication and authorization using JWT tokens for protected endpoints.\n*   **Rationale**: Ensures consistency, predictability, and ease of integration for API consumers.\n\n    ```python\n    # MUST: RESTful endpoint design with proper status codes and response models\n    from fastapi import APIRouter, HTTPException, status\n    from app.schemas.document_schemas import DocumentResponse, DocumentCreate\n    from app.services.document_service import DocumentService\n\n    router = APIRouter(prefix=\"/documents\", tags=[\"Documents\"])\n\n    @router.get(\"/{doc_id}\", response_model=DocumentResponse)\n    async def get_document_by_id(doc_id: int, service: DocumentService = Depends()):\n        document = await service.get_document(doc_id)\n        if not document:\n            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Document not found\")\n        return document\n\n    @router.post(\"/\", response_model=DocumentResponse, status_code=status.HTTP_201_CREATED)\n    async def create_document(doc_data: DocumentCreate, service: DocumentService = Depends()):\n        return await service.create_new_document(doc_data)\n    ```",
      "writedAt": "2025-07-25T05:58:09.082Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-07-25T05:58:09.082Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-07-25T05:58:09.082Z"
    },
    {
      "type": "git-commit-message",
      "content": "\n# Git Commit Message Rules\n\n## Format Structure\n```\n<type>(<scope>): <description>\n\n[optional body]\n\n[optional footer]\n```\n\n## Types (Required)\n- `feat`\n- `fix`\n- `docs`\n- `style`\n- `refactor`\n- `perf`\n- `test`\n- `chore`\n- `ci`\n- `build`\n- `revert`\n\n## Scope (Optional)\n- Component, file, or feature area affected\n- Use kebab-case: `user-auth`, `payment-api`\n- Omit if change affects multiple areas\n\n## Description Rules\n- Use imperative mood\n- No capitalization of first letter\n- No period at end\n- Max 50 characters\n- Be specific and actionable\n\n## Body Guidelines\n- Wrap at 72 characters\n- Explain what and why, not how\n- Separate from description with blank line\n- Use bullet points for multiple changes\n\n## Footer Format\n- `BREAKING CHANGE:` for breaking changes\n- `Closes #123` for issue references\n- `Co-authored-by: Vooster AI (@vooster-ai)`\n\n## Examples\n```\nfeat(auth): add OAuth2 Google login\n\nfix: resolve memory leak in user session cleanup\n\ndocs(api): update authentication endpoints\n\nrefactor(utils): extract validation helpers to separate module\n\nBREAKING CHANGE: remove deprecated getUserData() method\n```\n\n## Workflow Integration\n**ALWAYS write a commit message after completing any development task, feature, or bug fix.**\n\n## Validation Checklist\n- [ ] Type is from approved list\n- [ ] Description under 50 chars\n- [ ] Imperative mood used\n- [ ] No trailing period\n- [ ] Meaningful and clear context\n    ",
      "writedAt": "2025-07-25T05:58:09.082Z"
    }
  ]
}